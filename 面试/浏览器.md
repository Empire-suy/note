##### 从输入URL到页面加载的过程

1. 查找浏览器缓存，如果有该页面就显示该页面，没有就做浏览器的DNS解析
2. DNS域名解析 浏览器向服务器发起请求，解析URL中的域名对应的IP地址
3. 建立TCP连接[三次握手]
4. 然后发送HTTP请求
5. 服务器响应请求并返回结构
6. 关闭TCP连接[四次挥手]
7. 浏览器渲染: 浏览器解析服务器响应的HTML内容并渲染 大概流程是

  - 构建DOM树
  - 构建CSS规则树
  - 构建render树 [根据DOM树和CSS树 构建]

8. JS引擎解析过程 大致流程

- 创建window对象
- 加载文件[语法和词法分析，如果合法就进入预编译]
- 预编译
- 解释执行

##### 重绘和重排

重排/回流(reflow): DOM的变化影响到元素的几何信息，浏览器需要重新计算元素的集合属性，将其放到正确的位置，这个过程就做重排
重绘(Repaint): 当一个元素的外观发生变化，但是没有改变元素的几何信息，浏览器需要重新将元素的外观绘制，这个过程叫做重绘

重绘不一定出现重排，重排一定会出现重绘

##### 如何触发重排和重绘

任何构建渲染树的信息都会导致一次重排会重绘
比如

- 添加、删除、更新DOM节点
- 通过display: none; 隐藏一个DOM节点[重排和重绘]
- 通过visibility: hidden; [重绘]
- 用户的行为, 调整窗口的大小，改变字号, 滚动[重排和重绘]

##### 如何避免重绘或者重排

1. 批量改变样式
2. 需要动画的元素使用fixed 或者 absolute 属性， 修改的时候不会重排

##### 介绍一下304过程

1. 浏览器请求资源的时候命中Expires和Cache-Control
2. 强缓存失效，进入协商缓存
3. 协商缓存

##### 浏览器的缓存机制 强缓存和协商缓存

**强缓存**
控制字段为Expires和Cache-Control Cache-Control优先级比Expires高

1. 不存在缓存结果和缓存标识，强制缓存失效，直接向服务器发起请求
2. 存活该缓存结果和缓存标识，但结果已失效，强制缓存失效，使用协商缓存
3. 存在该缓存结果和缓存标识，且结果有效，强制缓存生效，直接返回该结果

**协商缓存**
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程
主要一下两种情况:

- 协商缓存生效: 304
- 协商缓存失效: 200 和请求结果

##### 说一下进程、线程和协程

进程：一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的独立单位

线程：一个单位的顺序控制流程，程序执行流的最小单元，一个进程可以有多个线程

协程：基于线程上，但比线程更加轻量级的存在，这种由程序员自己写程序来管理的轻量级线程叫做[用户空间线程]

##### Cookie、sessionStorage、localStorage的区别

**相同点:**

- 都是存储在客户端

**不同点:**

- cookie数据一般不能超过4kb，sessionStorage和localStorage比cookie大的多[5M]
- cookie 在设置的过期时间之前一直有效，sessionStorage在浏览器窗口关闭之后自动删除，localStorage在主动删除之前一直保留
- cookie的数据会在请求的时候带上传到服务器，但是sessionStorage和localStorage不会

#### XSS 跨站脚本攻击

- 在页面中插入可执行的网页脚本代码，当用户浏览该页的时候，嵌入web的脚本代码会被执行，从而达到攻击者盗用用户信息或者其他侵犯用户安全隐私的目的
- 利用cookie登录网站

1. 将cookie设置为http-only
2. 用户输入之后做过滤
3. 输出显示的时候对数据做转移处理

#### csrf 跨站请求伪造

劫持受信任用户向服务器发送非预期请求的攻击方式，通常情况下，CSRF攻击是攻击者借助受害者的Cookie骗取服务器的信任，在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在执行权限保护之下的操作

- SameSite 属性 Strict (不允许第三方的Cookie) | Lax (大多数情况不发送第三方Cookie，但是导航到目标网址的Get请求除外) | None
- 验证码
- token


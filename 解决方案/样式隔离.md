##### 样式隔离方案

1. CSS Modules

- 原理：构建时生成唯一类名（如 .button_3HjK8），实现局部作用域。

- 优点：

  - 真正的模块化，类名自动哈希，避免冲突。

  - 与现有 CSS 生态兼容，支持预处理器。

- 缺点：

  - 需配置构建工具（如 Webpack、PostCSS）。

  - 动态生成类名可能增加调试难度。

2. CSS-in-JS（如 styled-components、Emotion）

- 原理：将样式写入 JavaScript，运行时生成<style>标签，绑定到组件。

- 优点：

  - 动态样式能力强，支持主题和 props。

  - 自动隔离，无全局污染。

- 缺点：

  - 运行时开销可能影响性能。

  - 学习成本高，脱离标准 CSS 工作流。

3. BEM 命名规范

- 原理：通过命名约定（如 .block\_\_element--modifier）限定样式作用域。

- 优点：

  - 无需工具支持，纯 CSS 即可实现。

  - 结构清晰，易于维护。

- 缺点：

  - 依赖开发者自觉，命名冗长。

  - 大型项目中仍可能发生冲突。

4. Shadow DOM

- 原理：浏览器原生支持，将组件封装在独立 DOM 树中，样式隔离。

- 优点：

  - 彻底隔离，内外样式互不影响。

  - 支持原生组件开发（Web Components）。

- 缺点：

  - 与全局样式或第三方库兼容性差。

  - 学习成本高，部分框架集成困难。

5. Scoped CSS（如 Vue 的 <style scoped>）

- 原理：编译时为组件元素添加唯一属性（如 data-v-f3f3eg9），样式通过属性选择器限定。

- 优点：

  - 框架内置支持（如 Vue），开箱即用。

  - 无构建工具深度依赖。

- 缺点：

  - 选择器权重增加，可能影响覆盖。

  - 仅限组件内子元素，无法隔离子组件。

6. 命名空间（手动或工具生成）

- 原理：手动为根元素添加唯一类名（如 .app-navbar），后代样式基于此类名编写。

- 优点：

  - 简单易实现，无工具依赖。

  - 适用于小型项目或传统开发。

- 缺点：

  - 依赖开发者规范，容易遗漏。

  - 嵌套过深时选择器复杂。

7. 原子化/Utility-First CSS（如 Tailwind CSS）

- 原理：使用预定义的单一用途工具类（如 .mt-4）组合样式，减少自定义类。

- 优点：

  - 极大降低命名冲突风险。

  - 样式复用率高，维护一致性强。

- 缺点：

  - 需记忆大量类名，HTML 结构可能臃肿。

  - 不适合复杂设计场景。

8. 预处理器嵌套（如 Sass/Less）

- 原理：通过嵌套语法限定样式作用域，但编译后仍为全局 CSS。

- 优点：

  - 提升代码组织性，减少全局污染可能性。

  - 支持变量、混合等高级特性。

- 缺点：

  - 编译后仍为全局类名，隔离性弱。

  - 过度嵌套可能导致选择器复杂。

##### 方案对比与选型建议

- 追求彻底隔离：Shadow DOM（适合 Web Components）、CSS Modules。

- 动态样式需求：CSS-in-JS（React 生态首选）。

- 框架集成：Vue 用 Scoped CSS，React 用 CSS Modules 或 CSS-in-JS。

- 低工具依赖：BEM、命名空间或原子化 CSS。

- 平衡与兼容性：Scoped CSS 或 CSS Modules。

# 设计模式

定义：是一套被反复使用的、多数人知晓的、经过分类编目的代码设计经验的总结。

## 面向对象的设计原则
1. 单一职责原则【SRP】：一个类只负责一个功能领域中的相应职责
2. 开闭原则【OCP】：软件实体应对外扩展开放，对修改关闭
3. 里氏代换原则【LSP】：所有引用基类对象的地方能够透明地使用其他子类的对象
   在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。
   在运用里氏代换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现接口，并实现父类中声明的方法。
4. 依赖倒转原则【DIP】：抽象不应依赖于细节，细节应该依赖于抽象
5. 接口隔离原则【ISP】：使用多个专门的接口，而不使用单一的总接口
6. 合成复用原则【CRP】：尽量使用对象组合，而不是继承来达到复用的目的
7. 迪米特法则【LoD】/最少知识原则【LKP】：一个软件实体应当尽可能少地与其他实体发生相互作用

## 创建型模式

#### 单例模式
确保一个类只有一个实例，而且从实例化并向整个系统提供这个实例

要点：

1. 某个类只能有一个类
2. 必须自行创建这个实例
3. 必须自行向整个系统提供这个实例

##### 饿汉式单例和懒汉式单例【多线程环境】
1. 饿汉式单例
   
   实例在初始化的时候就被创建

   缺点：如果系统运行的时候不需要但是类又被加载了，会造成一定的资源浪费，而且在加载的时候由于需要创建单例对象，导致加载时间可能会比较长
2. 懒汉式单例

   初始化的时候不被创建，调用的才会被创建【需要加线程锁】，为了提高性能需要在实例化的时候才进行锁定，同时避免创建之后另外一个同时查询也在获取实例，但是这时候刚创建完，另外的线程还不知道已经创建了，这时候还需要在解锁后的执行实例化前实现第二次的判断。**【双重检查锁定】**

   缺点：在多个线程同时访问的时候，初始化可能会很消耗时间，意味着多线程同时引用此类的概率变得更大

3. Initialization on Demand Holder【IoDH】

   在类里面增加一个静态类，这个静态类的静态属性返回一个实例化的对象，查询的时候将该静态类作为结果返回

> 需要考虑的问题：如果共享的实例化对象长时间不使用，由于系统的垃圾回收机制，可能会被回收掉，导致下次初始化后状态丢失的问题。【具体看语言的垃圾回收机制】

#### 简单工厂模式
可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类

基本流程：将需要创建的不同的对象封装到不同的类【具体产品类】，将他们公共的代码抽象到一个抽象的产品类中，每个具体的产品类都是抽象产品类的子类。然后提供一个工厂方法用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据传入的参数不同创建不同的对象。客户端在调用的时候传入不同的参数即可得到一个产品对象。

简单工厂模式用于创建实例的方法是静态方法，因此简单工厂模式又称为静态工厂方法。

违背开闭原则

**适用场景**

1. 工厂类负责创建的对象比较少。由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
2. 客户端只知道传入工厂类的参数，对于如何创建对象并不关心。

#### 工厂方法模式
定义一个用于创建对象的接口，让子类决定将哪一个类实例化，又称为虚拟构造器模式/多态工厂模式/工厂模式。

在工厂方法模式中，不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供一个语产品等级结构对应的工厂等级结构。

相比于简单工厂模式引入了抽象工厂方法

#### 抽象工厂模式
提供一个创建一系列相关或者相互依赖对象的接口而无需执行它们具体的类【对象创建型模式】

##### 优缺点
1. 优点
   1. 当一个产品组的多个对象被设计成一起工作的时候，能够保证客户端始终只使用一个产品族的对象
   2. 新增产品族很方便，无需修改已有系统，符合开闭原则

##### 适用场景
1. 一个系统不应当依赖产品类实例如何被创建，组合和表达的细节
2. 系统有多于一个的产品族，而每次只使用其中一个产品族。
3. 属于同一个产品族的产品将在一起使用
4. 产品等级结构稳定，设计完成之后，不会向系统增加新的产品等级结构或删除已有的产品结构

#### 原型模式
使用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象
#### 建造者模式【Builder Pattern】
将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。是一种对象创建型模式


**优缺点**
- 优点
  1. 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象
  2. 每个具体建造者都相对独立，而与其他具体的建造者无关。符合开闭原则
  3. 可以更加精细地控制产品的创建过程

- 缺点
  1. 创建的产品一般具有较多的共同点，其组成部分相似，如果产品的差异性比较大的话，不适合使用建造者模式
  2. 产品的内部结构复杂多变，需要定义很多具体建造者来实现这种变化，导致系统变大，增加系统的理解难度和运行成本

**适用场景**
1. 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量
2. 需要生成的产品对象的属性相互依赖，需要指定其生成顺序
3. 对象的创建过程独立于创建该对象的类，在建造者模式中通过引入指挥者类，将创建过程封装在指挥者类中，而不是在建造者类和客户端类
4. 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品

## 结构型模式
#### 适配器模式

## 行为型模式

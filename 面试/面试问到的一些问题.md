#### 面试问的一些问题

1. 之前的工作内容
2. 之前离职的原因；个人的发展方向/职业规划
3. 可以到岗的时间，原单位的薪资结构，期望薪资
4. 面试请对方将一个他负责/参与的一个项目(和公司项目类似的或他认为有代表性的项目)，描述项目内容/周期/在项目中负责的内容(承担的角色)/对项目的评价/对项目其他同时的评价/可以改进的地方/项目的优缺点;面试官能从应聘者的面部表情、口述表达，反应谈吐沟通能力；另外从案例就能知道应聘者遇事会不会动脑子，是不是有解决问题的能力

#### 在线可以咨询的

1. 社保公积金购买，休息时间
2. 薪资范围
3. 团队架构，该岗位是新增还是替补

#### Real Dom 和 Virtual DOM 的区别 (汇丰软件)

Virtual DOM 本质上是以对象形式存在的对DOM的描述
创建虚拟DOM目的就是为了更好将虚拟的节点渲染到页面视图中，虚拟DOM对象的节点与真实DOM的属性一一对应

##### 区别

虚拟DOM不会进行排版与重绘操作，而真实DOM会频繁重排与重绘
虚拟DOM的总损耗是：虚拟DOM增删改 + 真实DOM差异增删改 + 排版与重绘，真实DOM的总损耗是：真实DOM完全增删改 + 重排与重绘

##### 优缺点

真实DOM的优势：易用
缺点：效率低，解析速度慢，内存占用量过高;性能差：频繁操作真实DOM，抑郁导致重绘与回流

虚拟DOM的优势
简单方便：手动操作真实DOM完成页面，繁琐且容易出错，在大规模应用下维护起来也很困难
性能方面：使用Virtual DOM，能有效避免真实DOM频繁更新，减少多次引起重绘与回流，提高性能
跨平台：React借助虚拟DOM，带来跨平台的能力，一套代码多端运行

缺点：
在一下性能要求极高的应用中虚拟DOM无法进行针对应的极致优化
首页渲染大量DOM时，由于多了一层虚拟DOM的计算，速度比正常稍慢

#### 工作流程 (汇丰软件)

#### watch 和 computed 的区别 (壹链盟)

**computed**

- 支持缓存，只有以来的数据发生变化，才会重新计算
- 不支持异步，当computed中有异步操作的时候，无法监听数据的变化
- computed 的值默认走缓存，计算属性是基于他们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算
- 如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值，在computed中，属性有一个get方法和set方法，当数据发生变化时，会调用set方法

**watch**

- 不支持缓存，数据变化，会触发相应的操作
- 支持异步监听
- 监听的函数接收两个参数，第一个参数是最新的值，第二个就是变化之前的值
- 当一个属性发生变化的时候，需要执行相应的操作
- 监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个参数
  immediate：组件加载立即触发回调函数
  deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。

**总结**

computed计算属性，依赖其他的属性值，并且computed的值有缓存，只有依赖的属性值发生变化，下一次获取computed的值时才会重新计算computed
watch侦听器，更过的是观察的作用，没有缓存，可以执行异步操作


#### 双向绑定的原理 (壹链盟)

Vue采用的是数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时，发布消息给订阅者，触发响应的监听回调

主要步骤：

1. 需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter，给这个对象的某个值赋值的时候，就会触发setter，监听到数据的变化
2. compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图
3. watcher 订阅者是Observer和Compile之间通信的桥梁，主要做的事情是：在自身实例化时往属性订阅器里面添加自己，自身必须要有一个update方法; 待属性变动dep.notice()通知的时候，调用自身的update方法，触发compile绑定的回调。
4. MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己地model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新 视图交互变化 -> 数据model更新的双向绑定效果

#### 数组更新不了的问题 (壹链盟)

#### 自定义组件 实现v-model (壹链盟)

@input 事件绑定 用户的输入 当用户输入的时候通过触发 $emit('input', $event.target.value)

绑定value的prop 实现数据的绑定更新

如果是checkbox 的话 需要绑定checked属性
  

#### 自定义指令 (壹链盟)

#### vuex 数据持久化 (壹链盟)

#### keep-alive原理 (壹链盟)

keep-alive 是一个内置的组件，可以将不活动的组件实例保存在内存中，是一个抽象的组件不会出现在父组件中。keep-alive的max属性，用于限制可以缓存组件的数量，如果缓存的组件达到这个数字，已缓存的组件中，访问时间最久的组件就会被销毁

LRU 缓存淘汰算法 (least recently used)

FIFO 队列

1. 将数据插入到连表尾部
2. 每当缓存命中（即缓存数据被访问），则将数据移到链表尾部
3. 当链表满的时候，将表格头部的数据丢弃

##### 原理

1. 使用LRU缓存机制进行缓存，max限制缓存表的最大容量
2. 根据设定的include/exclude进行条件匹配，决定是否缓存，不匹配，直接返回组件实例
3. 根据组件的ID和tag生成key，并在缓存对象中查找是否已缓存过该组件的实例，如果存在，直接取出缓存值并更新key在this.keys的位置
4. 获取节点名称或者根据节点cid等信息拼出当前组件名称
5. 获取keep-alive包裹着的第一个子组件对象及其组件名

#### diff 算法 (壹链盟)

#### provide/inject (壹链盟)

Vue中的依赖注入，用于父子组件通信

provide 用来发送数据或者方法
inject 用来接收数据或方法

跟data/methods 方法同级

```js
provide() {
  return {
    num: this.num
  }
}

inject: ['num']
```

#### 没有做过导入word和xlxs文件可以在线编辑的项目 (壹链盟)

没有

#### 隐藏元素的方法(医博)

#### 数组转成树状结构(医博)


#### 浏览器的内核 (网易)

Ie Trident
Firefox Gecko
Safari Webkit
Chrome Chromium/Blink
Opera Blink

#### 浏览器的事件流 EventLoop (网易)

1. 函数入栈，当栈中执行到异步任务的时候，将它分为WebAPIS，接着执行同步任务，知道调用栈为空
2. 其间webapis完成这件事，将回调函数放入队列中等待执行（微任务放到微任务队列中，宏任务放到宏任务队列）
3. 执行栈为空时，Event Loop把微任务队列执行清空
4. 微任务队列清空之后，进入宏任务队列，取队列的第一项任务放入栈中执行，执行完成后，查看微任务队列是否有任务，有的话，清空微任务队列。重复4，继续从宏任务中取任务执行，执行完成之后，继续清空微任务，如此循环，直至清空所有的任务

#### 垃圾回收机制 GC (网易)

垃圾: 程序不用的内存或者之前用过以后不会再用的内存空间

- 标记清除法 
  目前大多数浏览器采用的算法，大致流程：GC在运行时给内存中所有的变量都加上一个标记，假设内存中所有的对象都是垃圾，全标记为0，然后从各个跟对象开始遍历，把不是垃圾的节点改为1；然后清除所有标记0的垃圾，销毁并回收他们所占有的内存空间，最后，把所有内存中的对象标记为0，等待下一轮垃圾回收

  优点：实现比较简单
  缺点：标记清除之后导致内存空间不连续，出现内存的碎片

  解决方案：在标记结束之后，标记整理算法会将或者的对象向内存的一端移动，最后清除掉边界的内存[标记整理]

- 引用计数法
  跟踪每个变量值被使用的次数，比如，声明变量的时候，将一个引用类型赋值给该变量的时候这个值的引用次数就为1，如果同时一个值又被赋给另外一个值，那么引用的次数+1，如果该变量的值被其他的值覆盖了，则引用的次数-1，当值的引用次数为0的时候，说明该变量没有在使用，回收空间，GC会在运行的时候清理掉引用次数为0的值占用的内容

缺点：需要一个技术器，计算器需要占据很大的空间，当数据相互引用的时候，变量被清除的时候计数不为0，无法被清除掉

#### 浏览器的渲染机制 (网易)

- 处理HTML并构建DOM树
- 处理CSS构建CSS规则树(CSSOM)
- 将DOM树与CSS规则树合并成一个渲染树(Render Tree)
- 根据渲染树来布局，计算每个节点的位置
- 调用GPU绘制，合成图层，显示在屏幕上

#### 重绘和回流（网易）

- 重绘：页面中元素样式的改变不影响它在文档流中的位置，浏览器只需要将新样式赋予给新样式赋予给元素重新合并绘制
- 回流：页面元素的尺寸，结构或者某些属性发生改变时，浏览器重新渲染部分或全部文档的过程

回流一定会触发重绘，重绘不一定会触发回流，重绘的开销比较小，回调的成本比较高

#### 如何减少重排和重绘（提升性能）

- 避免频繁操作DOM，可以通过创建DocumentFragment，完成所有的DOM操作之后，再把它添加到文档中
- 避免频繁的操作样式，最好一次性重写style样式或者将样式列表定义成class并以此性应用操作class属性
- 对于具有复杂动画的元素使用绝对定位，使其脱离文档流，否则会引起父元素及后序元素频繁回流
- 避免频繁读取会引起回流/重绘的属性，如果需要多次使用，可以使用一个变量缓存起来

#### 浏览器的盒模型 (网易)

- 标准盒模型

盒子的大小 = content(内容区) + padding(填充区) + border(边框区)

```css
.box {
  box-sizing: content-box;
}

```

- 怪异盒模型

怪异盒模型的宽度：width(content + border + padding) + margin
样式设置了width之后，内容区根据border和padding进行压缩

```css
.box {
  box-sizing: border-box;
}
```

#### CSS3 硬件加速的样式（网易）

- transform
- opacity
- filter
- will-change

#### 怎么画一个三角形 (网易)

```css
.rec {
  width: 0;
  height: 0;
  border-bottom: 100px solid red;
  border-right:  100px solid transparent;
  border-left:  100px solid transparent;
}
```

#### 怎么画一个扇形

```css
.rec {
  width: 0;
  height: 0;
  border-bottom: 100px solid red;
  border-right:  100px solid transparent;
  border-left:  100px solid transparent;
}
```

#### 画一个自适应宽高的正方形

- 使用margin/padding实现

```css
.square {
  width: 20%;
  height: 0;
  padding-top: 20%;
  background: red;
}
```

- 利用vw实现

```css
.square {
  width: 10%;
  height: 10vw;
  background: red;
}
```

- 利用子元素的margin-top 实现

```css
.square {
  width: 30%;
  overflow: hidden;
  background: yellow;
}

.square::after {
  content: "";
  display: block;
  margin-top: 100%;
}
```

#### 水平居中， 垂直居中方式 (网易)

```css
.autoFix {
  display: flex;
  justify-content: center;
  align-items: center;
}
```

- 块级元素

```css
.parent {
  text-align: center;
  line-height: height;
}
```

#### 闭包（网易）

定义: 有权访问另外一个函数作用域中变量的函数

作用:

- 保护函数的私有变量不受外部的干扰，形成不销毁的栈内存
- 保存，把一些函数内的值保存下来，闭包可以实现方法和属性的私有化

#### 防抖、节流（网易）

节流：事件触发后，规定时间内，事件处理函数不能再次被调用

```js
function throttle(fn, delay) {
    //记录上一次函数触发的时间
    var lastTime = 0;
    return function(){
        //记录当前函数触发的时间
        var nowTime = Date.now();
        if(nowTime - lastTime > delay){
            //修正this指向问题
            fn.call(this);
            //同步执行结束时间
            lastTime = nowTime;
        }
    }
}
```

防抖：多次触发事件，事件处理函数只能执行一次，并且是触发操作结束后执行，也就是，当一个事件被触发准备执行事件函数前，会等待一定的时间，如果没有再次被触发，那么就会被执行，如果触发，本次作废，重新从触发的时间开始计算，并再次等待1秒，知道最终能执行

```js
function debounce(fn, delay) {
    //记录上一次的延时器
    var timer = null;
    return function () {
       //清除上一次的演示器
        clearTimeout(timer);
        //重新设置新的延时器
        timer = setTimeout(function(){
            //修正this指向问题
            fn.apply(this);
        }, delay); 
    }
}
```

#### 原型和原型链 (网易)

- 每个函数都有一个prototype 属性，这个属性指向函数的原型对象

原型链：函数的原型链对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针`__proto__` 这个指针指向上一层的原型对象，而上一层的原型对象的结构依然类似的，因此可以利用`__proto__`一直指向Object的原型对象上，而Object原型对象Object.prototype.`__proto__` = null 表示原型链的顶端，这样就形成了原型链

#### ES6 中的class 是怎么实现的 (网易)

通过构造函数的方式去构建的

原型链的继承

类的所有方法都定义在类的prototype属性上的

静态属性和静态方法绑定在类身上

super 作为函数调用的时候 代表父类的构造函数
super 在普通函数中作为对象调用 代表父类的原型对象
super 在静态方法中作为对象调用 代表父类的父类而不是原型对象

```js
function Person(name, age) {
  this.name = name
  this.age = age
}

Person.prototype.sayName = function() {
  return this.name
}

const xm = new Person('小明', 20)
console.log(xm)
```

#### 怎么修改this（网易）

#### await 怎么实现的（网易）

Async/Await就是一个自执行的generate函数。利用generate函数的特性把异步的代码写成“同步”的形式,第一个请求的返回值作为后面一个请求的参数,其中每一个参数都是一个promise对象.

#### Vue组件的通信方式 (网易)

- 父子组件 props/$emit
- $emit/$on 自定义事件 兄弟组件通信
- Event Bus 跨组件通信
- Vuex 跨级组件通信 provide inject

#### provide/inject 内部原理 (网易)

#### React Fiber (网易)

##### 背景

react-fiber,大量的同步计算任务阻塞浏览器的UI渲染，默认情况下，JS运算、页面布局和页面绘制都是运行在浏览器的主线程，相互互斥，运算占用主线程，页面就没法及时更新。当我们调用setState更新页面的时候，React会遍历应用所有的节点，计算出差异，然后再更新UI。如果页面元素很多，整个过程占用的时机可能占用16毫秒，容易出现掉帧的现象

##### 原理



#### React 生命周期（网易）

#### React 里面 key的作用（网易）


#### this.setState 是同步还是异步的 (网易)

异步： 在 React 可以控制的地方，就为 true，比如在 React 生命周期事件和合成事件中，都会走合并操作，延迟更新的策略。
同步： 在 React 无法控制的地方，比如原生事件，具体就是在 addEventListener 、setTimeout、setInterval 等事件中，就只能同步更新。

#### Vue、React Diff算法 (网易)

#### React 中组件通信（网易）

- 父传子 props
- 子传父 props + 回调
- context 跨级组件通信
  
  ```js
  const BatteryContext = createContext()

  <BatteryContext.Provider value={value}>
    <Child />
  </BatteryContext.Provider>

  <BatteryContext.Consumer>
    {value}
  </BatteryContext.Consumer>
  ```

#### webpack 中loader 和 plugins（网易）


#### redux (网易)

#### 项目中用的是mobx (最好复习一下)

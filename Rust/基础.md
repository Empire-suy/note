## 变量
使用let声明变量，如果需要修改需要声明mut
常量：使用const 声明，不可修改，不可使用mut，初始的时候需要显式声明变量类型
    命名规范：大写字母，单词使用_分割

**shadowing**
可以使用同名声明新的变量，后面使用的是这个新的变量

## 数据类型
### 标量类型
#### 整数
无符号整数以u开头，有符号整数以i开头

有符号范围: -2^n-1到2^n-1

无符号范围: 0到2^n-1

#### 浮点类型
单精度: f32 双精度: f64

#### 布尔
bool

### 复合类型
#### Tuple
每个位置对应一个类型
- 访问
    
    解构: let (x, y, x) = tup;

    点标记法: tup.0 tup.1

#### 数组
长度不可变

表示：[类型:长度]

#### 函数
参数必须声明类型

返回值[默认为最后一个表达式，如果最后一个为语句并且没有语句，那么函数的返回值默认为空的tuple]
```rs
fn plus(x: i32) -> i32 {
    x + 5
}

// 语句块的返回值为y + 8
let x = {
    let y = 32;
    y + 8
}
```

### 控制流
#### if表达式
必须为bool类型
```rs
let num = 3;
if num < 5 {
    println!('true')
} else {
    println!('false')
}


// 表示式
let condition = true;

let num = if condition { 5 } else { 6 };

println!(num)
```

#### 循环
- loop
- while
    ```rs
    let mut counter = 0;
    println!("{} before", counter);
    while counter < 10 {
        counter = counter + 1;
    }
    ```
- for
  ```rs
    let a = [20, 20, 30, 40];
    for ele in a.iter() {
        println!("value is {}", ele);
    }
  ```

#### range
生成两数之间的数字
```rs
for num in (1..4).rev() {
    println!("{}", num);
}
```

### 所有权
- 所有权解决的问题
  - 跟踪代码的哪些部分正在使用heap的哪些数据
  - 最小化heap上的重复数据
  - 清理heap上为使用的数据避免空间不足

- 所有权的规则
  - 每个值都有一个变量，这个变量是该值的所有者
  - 每个值同时只能有一个所有者
  - 当所有者超出作用域时，该值被删除

- 移动
  - stack上的数据进行复制
  - 简单的标量类型都可以copy
    - 所有的整型，浮点型，bool char，所有的字段可以copy的Tuple
  - 任何需要分配内存或某种资源的都不是copy

- 函数
  - 函数在返回值的过程中同样的也会发生所有权的转移
  - 一个变量的所有权会遵循、同样的模式
  - 把一个值赋给其他变量时会发生移动
  - 当一个包含heap数据的变量离开作用域时，它的值会被drop函数清理，除非数据的所有权移动到另外一个变量上
  - 引用和借用
    - 参数类型是&String
      
      &表示引用。允许引用某些值而不取得其所有权
    - 借用：把引用作为函数的参数
    - 引用默认是不可变的

  - 可变引用
    - 在特定作用域内，对某一块数据，只能有一个可变的引用
    - 数据竞争
      - 两个或多个指针同时访问同一个数据
      - 至少有一个指针用于写入数据
      - 没有使用任何机制来同步对数据的访问

    - 可以通过创建新的作用域来允许非同时创建多个可变引用
    - 不可以同时拥有一个可变引用和一个不可变引用

  - 悬空引用[dangling references]
    - 一个指针引用了内存的某个地址，而这块内存可能已经释放并分配给其他人使用来

  - 引用的规则
    - 任何时刻，只能满足下列条件之一
      - 一个可变引用
      - 任意数量不可变的引用

    - 引用必须一直有效
l
### 切片
